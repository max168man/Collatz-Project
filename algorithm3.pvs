%------------------------------------------------------------------------
%
% Algorithm 3
% Authors: Ali Ebnenasir <aebnenas@mtu.edu>, Maxwell Brainerd <mmbraine@mtu.edu>
% Date: 7/26/2024 - ongoing
%
% This is a helper algorithm to algorithm 2.
% It uses a nested for loop with variable depth n to compute Collatz numbers of the
% jth stair where 2 < qj < j - 2.
%
%------------------------------------------------------------------------

algorithm3: THEORY
BEGIN

IMPORTING Verification
IMPORTING strings
IMPORTING sequences[int]
IMPORTING finite_sequences

empty_sequence: sequence[int] = (LAMBDA (n: nat): 0)

% This testing method is used to print every member of a sequence, starting from the first to the last.
print_list(seq_length: nat, seq: sequence[nat]): bool =
  print("[") AND
  FORALL(x:subrange(0, seq_length)): 
    IF x /= seq_length THEN
      print(seq(x)) AND print(", ")
    ELSE print(x) AND println("]")
    ENDIF
  AND TRUE

recursiveListCreationBool(l, seq_length: nat, seq: sequence[int]): RECURSIVE bool = % Corresponds to line 8 in algorithm
  IF l = 0 THEN
    LET seq = add(l, seq) IN print_list(seq_length, seq) 
  ELSE
    LET seq = add(l, seq) IN recursiveListCreationBool(l - 1, seq_length + 1, seq) AND print("(For loop) ") AND LET seq = add(l, seq) IN print_list(seq_length + 1, seq)  
  ENDIF
  MEASURE l

recursiveListCreation(l, seq_length: nat, seq: sequence[int]): RECURSIVE sequence[int] = % Corresponds to line 8 in algorithm
  IF l = 0 THEN
    add(l, seq) 
  ELSE
    LET seq = add(l, seq) IN recursiveListCreation(l - 1, seq_length + 1, seq)
  ENDIF
  MEASURE l
    
%%%
% alg3
% param n: Length of the summation in the later "num" calculation
% origN: 
% Y_k:
% l: Maximum exponent for the powers of 2 used in the summation for num
% j: Current stair
% qj: Passed from algorithm 2
% seq: An empty sequence used for later calculations.
%
% This algorithm uses a nested for loop to compute Collatz numbers of the j-th stair where 2 < qj < j - 2.
%%%

recursiveFor(n, origN, Y_k: int, l, j, qj: nat, seq: sequence[int], seq_length: nat): RECURSIVE boolean = % Corresponds to line 1 in algorithm
  println("") AND print("Beginning list (1): ") AND print_list(seq_length, seq)  AND
  IF n > 1 THEN
    print("case n > 1, n = ") AND println(n) AND 
    % Adds every value starting from l to 0 to 
    FORALL(x:subrange(0, l)):
        print("x = ") AND println(l-x) AND print("Beginning list: ") AND print_list(seq_length, seq)  AND 
        recursiveFor(n - 1, origN, Y_k, l, j, qj, add(l-x, seq), seq_length + 1)
  ELSE
    println("case n <= 1") AND 
    LET sequence = seq IN recursiveListCreationBool(l, 0, sequence)
  ENDIF
MEASURE n

recursiveForEnhanced(n, origN, Y_k: int, x, l, j, qj: nat, seq: sequence[int], seq_length: nat): RECURSIVE boolean =
  IF n = 1 THEN
    LET sequence = seq IN recursiveListCreationBool(l, 0, sequence)
  ELSIF x >= 0 THEN
    print("x = ") AND println(l-x) AND print("Beginning list: ") AND print_list(seq_length, seq) AND
    recursiveForEnhanced(n - 1, origN, Y_k, x, l, j, qj, add(l-x, seq), seq_length + 1) AND
    recursiveForEnhanced(n, origN, Y_k, x - 1, l, j, qj, delete(origN - n, (add(l-x, seq))), seq_length + 1)
  ELSE
    TRUE
  ENDIF
  MEASURE n
%%%
% alg3
% param n: Length of the summation in the later "num" calculation
% origN: 
% Y_k:
% l: Maximum exponent for the powers of 2 used in the summation for num
% j: Current stair
% qj: Passed from algorithm 2
%
% This algorithm calls upon a nested for loop to compute Collatz numbers of the j-th stair where 2 < qj < j - 2.
% It is essentially a "portal" to the actual recursiveFor algorithm; this is done so an empty sequence can be passed into recursiveFor, for later use.
%%%

alg3(n, origN, Y_k: int, l, j, qj: nat): boolean =
  print("alg3 reached, n = ") AND println(n) AND LET sequence = empty_sequence in recursiveForEnhanced(n, origN, Y_k, l, l, j, qj, sequence, 0)

END algorithm3