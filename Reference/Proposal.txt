Mechanical Verification of the Convergence Stairs of the

Collatz Program
Maxwell Brainerd
May 2024

1 Introduction
The goal of this project is to mechanically prove the correctness of the convergence stairs of the Collatz
conjecture formally specified in [5]. The Collatz conjecture is considered the simplest unsolved math
problem due to the simplicity of understanding it, but the complexity of proving it. (The Collatz
conjecture has remained an open problem for more than six decades.) Consider the function fc over
a variable x whose domain and range include the set of positive integers, denoted N : if x is an even
value, then update x with fc(x) = x/2; otherwise, assign fc(x) = 3x + 1 to x. Intuitively, divide
x by two if x is even; otherwise; multiply x by three and add one. Then, repeat the same process
with the new value of x. Thus, starting from a positive integer n, one can define a sequence of values
n, fc(n), f 2
c
(n), f 3
c
(n), · · · obtained by repetitive application of the Collatz function fc, called the orbit

of n. Let fmin(n) be the minimum value in {n, fc(n), f 2
c
(n), f 3
c
(n), · · ·}. The Collatz conjecture simply

asks the question of whether fmin(n) = 1 for any positive integer n.
The significance of the Collatz conjecture from the Computer Science point of view lies in its
applications in several domains such as image encryption [1], software watermarking [9], proof of work
in blockchain [2] and in designing the stability of complex and non-linear systems [8] that have chaotic
behaviors, yet ensuring eventual stability. The notion of eventual stability is common knowledge
in Computer Science in general, and in the self-stabilization community in particular, however, the
behaviors of Collatz function defy any known type of convergence-assurance approach (e.g., ranking
functions [10], convergence stairs [7, 6]) as we know it in self-stabilizing systems. Moreover, while
there are other distributed programs with unbounded variables (e.g., Dijkstra’s token passing [4]),
the domain of such unbounded variables often increases as the network size grows; i.e., unbounded
but finite. This is not the case in Collatz function, and the domain of x is infinite in a two-process
concurrent program. As a result, the Collatz problem poses an interesting challenge for formal methods
and program verification research too.
2 Proposed Work
While there is a rich body of work in mathematics on Collatz problem, the most recent result states
that “Almost all Collatz orbits attain almost bounded values.” [11], where the notion of “almost all”
is defined in the context of logarithmic density. We take a different approach by first formulating the
Collatz function as a concurrent program. Then, we reformulate the Collatz problem as a problem
of specifying and verifying the convergence of the Collatz programs through the specification of an
unbounded number of convergence stairs. Each convergence stair is in fact a set of natural values
from where the set Icltz = {1, 2, 4} can be reached in j > 0 steps of applying the Collatz function fc.
Formally, the j-th convergence stair, denoted Sj , is equal to the set {n | f
j
c
(n) ∈ Ic}. (Notice that,
S0 = Icltz.) In [5], the authors devise a scheme, where given j > 0, one can specify and compute all
the values in Sj without expanding and exploring the binary tree generated by backward reachability
from {1, 2, 4}. This way, the Collatz conjecture would be reduced to proving that (1) ∪∞
j=0Sj = N ,
and (2) from each stair j > 0 the Collatz program reaches a value in stair j − 1. Not only does
this approach provide a different method of tackling the Collatz conjecture, but it also enables an
algorithmic way for analyzing the behavior of every individual stair. Moreover, for the first time, the
algorithmic method in [5] provides a layered and linearized orientation of Collatz numbers organized

1

in an infinite set of infinite binary trees. Such linearization methods can provide insight in addressing
other similar conjectures (e.g., Kakutani conjectures [3]). More importantly, it can help researchers in
understanding and testing of the behaviors of complex non-linear computing systems.
Our goal in this project is to formally specify and mechanically verify the algorithmic method of
[5] using the Prototype Verification System (PVS). While the correctness of convergence stairs has
already been established in [5], those proofs are manual and may contain flaws. A mechanical proof
of correctness for the proposed convergence stairs in [5] will be a significant step towards solving the
conjecture as it will provide ultimate assurance in the correctness of the proofs in [5]. Once we have
the mechanical proofs of the convergence stair, we can embark on proving (respectively, disproving)
the conjecture by showing that the union of the stairs is equal to (respectively, not equal to) the
set of natural values. In the case of disproving this equality, we will identify a set of values from
where the Collatz conjecture does not hold. The formal specifications and the proof strategies of
the convergence stairs in PVS will also provide a reusable library for formal specification and
verification of non-linear infinite-state systems. Last but not least, the results of this project
will increase confidence in the correctness of a software tool (available at https://github.com/aebne/
CollatzStairs) that has been developed based on the algorithm in [5] for generating the Collatz
convergence stairs (or can reveal potential design flaws in it).
3 Evaluation
The main task of evaluation will be intertwined with our efforts for formal verification. Theorem
provers such as PVS will help us identify ambiguous assumptions and subtle flaws that may be hidden
in the manual proofs. As a result, the validation activities of this project actually go hand in hand
with the task of formal specification and verification using the decision procedures integrated in PVS.
4 Project Timeline
I have already started learning PVS and I will finish a hands-on tutorial by the end of May. We plan
to work on formal specification of the lemmas and theorems in [5] until the end of June, and will work
on the verification aspects until Mid-August. We are aware of the complexity of this task and we plan
to continue working on the verification tasks in the fall semester if we have incomplete proofs by the
end of summer.
References
[1] D. M. Ballesteros, J. Pe ̃na, and D. Renza. A novel image encryption scheme based on collatz
conjecture. Entropy, 20(12):901, 2018.
[2] F. Bocart. Inflation propensity of collatz orbits: a new proof-of-work for blockchain applications.
Journal of Risk and Financial Management, 11(4):83, 2018.

[3] F. Briscese and F. Calogero. Conjectures analogous to the collatz conjecture. Open Communica-
tions in Nonlinear Mathematical Physics, 2024.

[4] E. W. Dijkstra. Self-stabilizing systems in spite of distributed control. Communications of the
ACM, 17(11):643–644, 1974.
[5] A. Ebnenasir. Specifying and verifying the convergence stairs of the collatz program, 2024. https:
//arxiv.org/abs/2403.04777.
[6] M. Gouda. Multiphase stabilization. IEEE Transactions on Software Engineering, 28(2):201–208,
2002.
[7] M. G. Gouda and N. J. Multari. Stabilizing communication protocols. IEEE Transactions on
Computers, 40(4):448–458, 1991.
[8] J. A. Grauer. Analogy between the collatz conjecture and sliding mode control. 2021.

2

[9] H. Ma, C. Jia, S. Li, W. Zheng, and D. Wu. Xmark: dynamic software watermarking using collatz
conjecture. IEEE Transactions on Information Forensics and Security, 14(11):2859–2874, 2019.

[10] F. Stomp. Structured design of self-stabilizing programs. In Proceedings of the 2nd Israel Sympo-
sium on Theory and Computing Systems, pages 167–176, 1993.

[11] T. Tao. Almost all orbits of the Collatz map attain almost bounded values. In Forum of Mathe-
matics, Pi, volume 10. Cambridge University Press, 2022.
